> [Course](https://stepik.org/course/63054/promo)

### Тренажеры
[sqlbolt](https://sqlbolt.com/)  
[sql-ex](https://sql-ex.ru/)

## 1. Основы реляционной модели и SQL
### 1.1 Таблица
#### Теоретические тезисы
- Название таблицы в DB - существительное в единственном числе.  
Рекомендуется использовать только строчные (маленькие) буквы (это касается и наименований столбцов).  
- В названии таблиц и столбцов допускаются только: буквы, цифры и `_` 
- Шаблон имени для PK: `tablename_id`.  
- SQL не является регистро-зависимым языком, но рекомендуется писать ключевые слова прописными (большими), а наименования строчными (маленькими) буквами.

#### Типы данных

|**Тип данных**|**Описание**|**Пример**|
|---|---|---|
|`INT`   <br>`INTEGER`|Целое число, могут принимать значения  <br>от -2 147 483 648 до 2 147 483 647|-567  <br>1205|
|`DECIMAL`  <br>`NUMERIC`|Вещественное число,  <br>в скобках указывается максимальная  <br>длина числа (включает символы слева и справа от десятичной запятой)  <br>и количество знаков после запятой.  <br>Можно использовать оба этих типа, они эквивалентны,  <br>принимают значения в диапазоне -1038+1 до 1038-1.  <br>`DECIMAL(4,1)    NUMERIC(6,3)`|34.6  <br>-3.294|
|`DATE`|Дата в формате ГГГГ-ММ-ДД   <br>_26 июля 2020 года  <br>3 января 2021 года_|2020-07-26  <br>2021-01-03|
|`VARCHAR`|Строка длиной не более 255 символов, <br>в скобках указывается максимальная  <br>длина строки, которая может храниться в поле <br>`VARCHAR(10)(рассматриваются однобайтовые кодировки, для которых число в скобках соответствует максимальному   количеству символов в строке)`|пример  <br>описание|
#### Создание таблицы
```sql
CREATE TABLE book(
book_id INT PRIMARY KEY AUTO_INCREMENT,
title VARCHAR(50),
author VARCHAR(30),
price DECIMAL(8, 2),
amount INT
);
```

#### Добавление данных в таблицу
```sql
INSERT INTO book (title, author, price, amount)
VALUES ('Мастер и Маргарита', 'Булгаков М.А.', 670.99, 3);

INSERT INTO book (title, author, price, amount)
VALUES
('Белая гвардия', 'Булгаков М.А.', 540.5, 5),
('Идиот', 'Достоевский Ф.М.', 460, 10),
('Братья Карамазовы', 'Достоевский Ф.М.', 799.01, 2);
```

### 1.2 Выборка данных
#### Выборки из таблицы
```sql
SELECT * FROM book;
SELECT author, title, price FROM book;
```
> Выборка с заданием новых имен столбцам при отображении (новое имя может быть написано кириллицей, главное без пробелов):
```sql
SELECT title AS Название, author AS Автор, amount
FROM book;
```
![[Pasted image 20240325181016.png]]

> Выборка с созданием нового вычисляемого столбца при отображении:
```sql
SELECT title, author, price, amount, price * amount AS total
FROM book;

SELECT title, amount, amount * 1.65 AS pack
FROM book;
```
Для вычисляемого столба в списки полей **указывается выражение** (может включать: имена столбцов, константы, знаки операций, встроенные ф-ии) и **задается имя**.

#### Математические ф-ии в SQL
|**Функция**|**Описание**|**Пример**|
|---|---|---|
|`CEILING(x)`|возвращает наименьшее целое число, большее или равное **x**  <br>(округляет до целого числа в большую сторону)|`CEILING(4.2) = 5   CEILING(-5.8) = -5`|
|`ROUND(x,k)`|округляет значение **x** до **k** знаков после запятой,  <br>если **k** не указано – **x** округляется до целого|`ROUND(4.361) = 4   ROUND(5.86592, 1) = 5.9`|
|`FLOOR(x)`|возвращает наибольшее целое число, меньшее или равное **x**  <br>(округляет до  целого числа в меньшую сторону)|`FLOOR(4.2) = 4` <br>`FLOOR(-5.8) = -6`|
|`POWER(x,y)`|возведение **x** в степень **y**|`POWER(3, 4) = 81.0`|
|`SQRT(x)`|квадратный корень из **x**|`SQRT(4) = 2.0` <br>`SQRT(2) = 1.41...`|
|`DEGREES(x)`|конвертирует значение **x** из радиан в градусы|`DEGREES(3) = 171.8...`|
|`RADIANS(x)`|конвертирует значение **x** из градусов в радианы|`RADIANS(180) = 3.14...`|
|`ABS(x)`|модуль числа **x**|`ABS(-1) = 1` <br>`ABS(1) = 1`|
|`PI()`|pi = 3.1415926...||

Пример запроса :
```sql
SELECT title,
       author,
       amount,
       ROUND(price * 0.7, 2) AS new_price
FROM book;
```
![[Pasted image 20240327223826.png]]

#### Логические ф-ии

> `IF(expression, выражение_1, выражение_2)`
> 
> Функция вычисляет `expression`,
> если оно `true` – возвращается  `выражение_1`, если `false` –  `выражение_2`
> 
> Все три параметра `IF()` являются обязательными.
> вместо `выражение_1` или `выражение_2` может стоять новая функция `IF()`

Примеры запросов :
```sql
SELECT title, amount, price,
ROUND(IF(amount < 4, price * 0.5, price * 0.7), 2) AS sale
FROM book;
```
![[Pasted image 20240328171119.png]].

```sql
SELECT author, title, price,
ROUND(IF(author = 'Булгаков М.А.',
		 price * 1.1,
		 IF(author = 'Есенин С.А.', price * 1.05, price)), 2) AS new_price  
FROM book;
```
![[Pasted image 20240328170927.png]]

#### Выборка данных по условию
> С помощью ключевого слова `WHERE` можно включать в итоговую выборку только те строки, которые отвечают некоторому условию.
> 
> Ключевое слово `WHERE` используется после указания таблицы.
> 
> Логическое выражение может включать **операторы сравнения** (равно «**=**», не равно «**<>**», больше «**>**», меньше «**<**», больше или равно«**>=**», меньше или равно «**<=**») и выражения, допустимые в SQL.

Примеры запросов :
```sql
SELECT author, title, price  
FROM book  
WHERE amount < 10;
```

> В логическом выражении после `WHERE` нельзя использовать названия столбцов, присвоенные им с помощью `AS`,  так как при выполнении запроса сначала вычисляется логическое выражение для каждой строки исходной таблицы, выбираются строки, для которых оно истинно. А только после этого формируется "шапка запроса" – столбцы, включаемые в запрос.
```sql
SELECT title, author, price * amount AS total
FROM book
WHERE price * amount > 4000;
```

##### Логические операции
После ключевого слова `WHERE` могут использоваться:
- операторы сравнения
- выражения (`IN`, `BETWEEN`)
- **логические операции** (И «**and**», ИЛИ «**or**», НЕ «**not**») и круглые скобки, изменяющие приоритеты выполнения операций.

Приоритеты операций:
1. круглые скобки
2. умножение  (*),  деление (/)
3. сложение  (+), вычитание (-)
4. операторы сравнения (=, >, <, >=, <=, <>)
5. NOT
6. AND
7. OR

Примеры запросов :
```sql
SELECT title, author, price
FROM book
WHERE price > 600 AND author = 'Булгаков М.А.';
```

```sql
SELECT title, author, price, amount  
FROM book  
WHERE (price > 600 OR price < 500) AND price * amount >= 5000;
```

##### Операторы IN, BETWEEN
> Приоритет у этих операторов такой же, как у операторов сравнения (`=`, `>`, `<`, `>=`, `<=`, `<>`)

> `BETWEEN` позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.

```sql
SELECT title, amount
FROM book
WHERE amount BETWEEN 5 AND 14;
```
Аналогичный запрос:
```sql
SELECT title, amount
FROM book
WHERE amount >= 5 AND amount <=14;
```

> `IN` позволяет выбрать данные, соответствующие значениям из списка.

```sql
SELECT title, price
FROM book
WHERE author IN ('Булгаков М.А.', 'Достоевский Ф.М.');
```
Аналогичный запрос:
```sql
SELECT title, price
FROM book

WHERE author = 'Булгаков М.А.' OR author = 'Достоевский Ф.М.';
```

#### Сортировка
> `ORDER BY` позволяет сортировать выборку данных по одному  или нескольким столбцам

При этом, если указано два столбца, строки всегда сортируются только по первому столбцу, сортировка по второму осуществляется только для строк, у которых значения первых столбцов одинаковые.<br>
По умолчанию `ORDER BY` выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки вручную после имени столбца(-ов) ставится ключевое слово:
 - `ASC` - по возрастанию
 - `DESC` - по убыванию

Синтаксис:
```sql
SELECT *
FROM table_name
WHERE column_1 > 500
ORDER BY column_1, column_2 DESC
```

Столбцы после ключевого слова `ORDER BY` можно задавать:
- названием столбца
- номером столбца
- именем столбца (указанным после `AS`)

Примеры:

```sql
SELECT title, author, price
FROM book
ORDER BY title;

Аналогичный запрос:

SELECT title, author, price
FROM book
ORDER BY 1;
```

<br>
Разберем данный пример подробнее:

```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, amount DESC;

Другие варианты записи запроса:

SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, Количество DESC;

SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY 1, 3 DESC;

```

![[Pasted image 20240331143725.png]]

1. Сортировка осуществляется по первому столбцу (`author`).
   Ключевое слово `DESC` относится только ко второму столбцу, по этому тут оно не учитывается.
2. Строки с одинаковыми первыми столбцами сортируются по второму столбцу в обратном порядке.

#### Оператор LIKE
> `LIKE` используется для сравнения строк в соответствии с указанным шаблоном, а не на полное совпадение/не совпадение.

Шаблон может включать **обычные символы** и **символы-шаблоны**

|**Символ-шаблон**|**Описание**|
|---|---|
|**%**|Любая строка, содержащая ноль или более символов|
|**_** (подчеркивание)|Любой одиночный символ|

Синтаксис:
```sql
SELECT *
FROM table_name
WHERE column_1 LIKE 'Б%'
/* эквивалентное условие column_1 LIKE 'б%' */
```
- шаблон не зависит от регистра.

Примеры:
1. Выбрать все `book` с `title` из 5 символов
```sql
SELECT title
FROM book
WHERE title LIKE "_____"
```

2. Выбрать все `book` в `title` которых нет ни одного пробела
```sql
SELECT title
FROM book
WHERE title NOT LIKE "% %";
```

### 1.3 Запросы, групповые операции
#### Выбор уникальных элементов столбца
> Ключевое слово `DISTINCT` используется для отбора уникальных эл-тов столбца.
> `DISTINCT` размещается сразу после `SELECT`

Пример запроса:
```sql
SELECT DISTINCT author
FROM book;
```

Такого же результата можно добиться с помощью оператора `GROUP BY` (но прям для такого же результата необходимо и группировать и выбирать по одному, нужному столбцу):
```sql
SELECT author
FROM book
GROUP BY author;
```

> `DISTINCT` можно применять к столбцам внутри sql ф-ий

```sql
SELECT author, SUM(DISTINCT price)  
FROM book  
GROUP BY author;
```


#### Выборка данных, групповые ф-ии
##### SUM и COUNT
> При группировке элементов столбца эл-ты, входящие в каждую группу, можно просуммировать или подсчитать их кол-во.

<font style="color:red">ВАЖНО</font>: если столбец указан в `GROUP BY`, то он должен быть указан и в `SELECT`.

Пример запроса:
```sql
SELECT author, SUM(amount), COUNT(amount)
FROM book
GROUP BY author;
```
 
 > Ф-ию `COUNT` можно применять к любому столбцу, в том числе и использовать `*`.
 > Если столбец, по которому производится подсчет ф-ей `COUNT` имеет значение `null` - данное значение не будет учтено.
 > 
 > `COUNT(*)` - подсчитывает все записи, относящиеся к группе, в том числе и со значением `null`.
 
Пример данных таблицы подобного кейса:
![[Pasted image 20240413012711.png]]

```sql
SELECT author, COUNT(author), COUNT(amount) AS Количество_книг, COUNT(*)
FROM book
GROUP BY author;
```

![[Pasted image 20240420135855.png]]
- Название столбцов (указываемое через `AS`) может состоять из нескольких слов, тогда их нужно заключать в кавычки. Но если слова написать через подчеркивание, тогда получится , что название состоит из одного слова, и кавычки можно не ставить.

##### MIN, MAX, AVG
> К групповым функциям SQL относятся: `MIN()`, `MAX()` и `AVG()`, которые вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.

```sql
SELECT author, MIN(price) AS min_prise
FROM book
GROUP BY author;
```

##### Выборка с вычислением
> В качестве аргумента групповых функций  SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение.
> А так же групповые функции могут быть элементами выражений.

```sql
SELECT author, SUM(price * amount) AS Стоимость_всех_книг
FROM book
GROUP BY author;

SELECT author, ROUND(AVG(price), 2) AS Средняя_цена
FROM book
GROUP BY author;
```

- Имена столбцов, присвоенные им с помощью `AS`, нельзя использовать в выражениях, только названия столбцов исходной таблицы.
```sql
SELECT author,  
ROUND(SUM(price * amount), 2) AS Стоимость,  
ROUND(SUM(price * amount) * 18 / 118, 2) AS НДС,  
ROUND(SUM(price * amount) * 100 / 118, 2) AS Стоимость_без_НДС  
FROM book  
GROUP BY author;
```

#### Вычисления по таблице целиком
> Групповые функции позволяют вычислять итоговые значения по всей таблице.
> После ключевого слова `SELECT` указывается групповая функция для выражения или имени столбца, а ключевые слова `GROUP BY` опускаются.

```sql
SELECT SUM(amount) AS Количество, SUM(price * amount) AS Стоимость
FROM book;
```
 - Результатом таких запросов является единственная строка с вычисленными по таблице значениями.
![[Pasted image 20240413200129.png]]

#### Выборка данных по условию
> В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после `WHERE`. В запросах с групповыми функциями вместо `WHERE` используется ключевое слово `HAVING` , которое размещается после оператора `GROUP BY`.

```sql
SELECT author,
       MIN(price) AS Минимальная_цена,
       MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000;
```

- Также в запросах с группировкой можно сортировать данные:
```sql
SELECT author,
       MIN(price) AS Минимальная_цена,
       MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000
ORDER BY Минимальная_цена DESC;
```

- Если в запросе с групповыми функциями отсутствует `GROUP BY`, то для отбора записей используется ключевое слово `WHERE`.

```sql
SELECT ROUND(AVG(price), 2) AS Средняя_цена
FROM book
WHERE amount BETWEEN 5 AND 14;
```

##### WHERE и HAVING
> `WHERE` и `HAVING` могут использоваться в одном запросе.

 При этом необходимо учитывать **порядок выполнения  SQL запроса на выборку на СЕРВЕРЕ**:
1. FROM
2. WHERE
3. GROUP BY
4. HAVING
5. SELECT
6. ORDER BY

> 1. Сначала определяется таблица, из которой выбираются данные (`FROM`).
> 2. Затем из этой таблицы отбираются записи в соответствии с условием  `WHERE`.
> 3. Выбранные данные агрегируются (`GROUP BY`).
> 4. Из агрегированных записей выбираются те, которые удовлетворяют условию после `HAVING`.
> 5. Потом формируются данные результирующей выборки, как это указано после `SELECT` ( вычисляются выражения, присваиваются имена и пр. ).
> 6. Результирующая выборка сортируется, как указано после `ORDER BY`.

<font style="color:red">ВАЖНО</font>:
Порядок ВЫПОЛНЕНИЯ запросов - это не порядок ЗАПИСИ ключевых слов в запросе на выборку.
Порядок записи (синтаксис запроса) остается таким же, как рассматривался ранее.
Порядок ВЫПОЛНЕНИЯ  нужен для того, чтобы понять, почему, например, в `WHERE` нельзя использовать имена выражений из `SELECT`. Просто `SELECT` выполняется компилятором позже, чем `WHERE`, поэтому ему неизвестно, какое там выражение написано

```sql
SELECT author,
       MIN(price) AS Минимальная_цена,
       MAX(price) AS Максимальная_цена
FROM book
WHERE author <> 'Есенин С.А.'
GROUP BY author
HAVING SUM(amount) > 10;
```

Запрос с аналогичным результатом:
```sql
SELECT author,
       MIN(price) AS Минимальная_цена,
       MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(amount) > 10 AND author <> 'Есенин С.А.';
```
- Но это менее эффективный запрос, так как мы выберем всех авторов из таблицы, сгруппируем по ним, и только после этого уберем `Есенина`. 
  А могли бы изначально не выбирать его из таблицы.
- Всевозможные фильтры лучше ставить как можно раньше.

### 1.4 Вложенные запросы
Вложенный запрос может включать в себя следующие компоненты:
- Обязательные: `SELECT`, `FROM`
- Не обязательные: `WHERE`, `GROUP BY`, `HAVING`

Вложенные запросы могут использоваться после `WHERE`, `HAVING`, а так же `SELECT`.

#### Вложенный запрос, возвращающий одно значение
```sql
SELECT title, author, price, amount
FROM book
WHERE price = (SELECT MIN(price) FROM book);

SELECT author, title, price
FROM book
WHERE price <= (SELECT AVG(price) FROM book)
ORDER BY price DESC;
```

#### Использование вложенного запроса в выражении
> Вложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд.

Вывести inf-ю о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на `3` :
```sql
SELECT title, author, amount
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) > 3;
```

Вывести книги, цены которых превышают минимальную цену книги на складе не более чем на 150 рублей в отсортированном по возрастанию цены виде:
```sql
SELECT author, title, price
FROM book
WHERE (price - (SELECT MIN(price) FROM book)) BETWEEN 0 AND 150
ORDER BY price;
```

#### Вложенный запрос, оператор IN
> Вложенный запрос может возвращать несколько значений одного столбца. 
> Тогда его можно использовать в разделе `WHERE` совместно с оператором `IN` :

```sql
WHERE имя_столбца IN (вложенный запрос, возвращающий ОДИН СТОЛБЕЦ)
```

- Оператор `IN` определяет, совпадает ли значение столбца с одним из значений, содержащихся во вложенном запросе.
- Оператор `NOT IN` выполняет обратное действие.

Вывести inf-ю о книгах тех авторов, общее количество экземпляров книг которых не менее 12 :
```sql
SELECT title, author, amount, price
FROM book
WHERE author IN(
		SELECT author
		FROM book
		GROUP BY author
		HAVING SUM(amount) >= 12
		);
```

Вывести inf-ю о книгах, количество экземпляров которых в таблице `book` не дублируется :
```sql
SELECT author, title, amount
FROM book
WHERE amount IN(
		SELECT amount
		FROM book
		GROUP BY amount
		HAVING COUNT(amount) = 1
		/* HAVING COUNT(*) = 1 - можно и так
		*/
		);
```

#### Вложенный запрос, операторы ANY и ALL
> Операторы `ANY` и `ALL` используются  в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца.
> 
> Операторы `ANY` и `ALL` используются совместно с операциями отношения (=, <>, <=, >=, <, >)
> 
> Операторы `ALL` и `ANY` можно использовать **только со вложенными запросами**.

**ANY** -  в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно <font style="color:red">хотя бы для одного элемента</font> результирующего (вложенного) запроса.

- `amount > ANY (10, 12)` эквивалентно `amount > 10`
- `amount < ANY (10, 12)` эквивалентно `amount < 12`
- `amount = ANY (10, 12)` эквивалентно `(amount = 10) OR (amount = 12)`, а также `amount IN  (10,12)`
- `amount <> ANY (10, 12)` вернет все записи с любым значением `amount,` включая 10 и 12, так как эквивалентно `(amount <> 10) OR (amount <> 12)` 

**ALL** - в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно <font style="color:red">для всех элементов</font> результирующего запроса.

- `amount > ALL (10, 12)` эквивалентно `amount > 12`
- `amount < ALL (10, 12)` эквивалентно `amount < 10`
- `amount = ALL (10, 12)` не вернет ни одной записи, так как эквивалентно `(amount = 10) AND (amount = 12)`
- `amount <> ALL (10, 12)` вернет все записи кроме тех,  в которых`amount равно 10 или 12`

Вывести информацию о тех книгах, количество которых меньше самого маленького среднего количества книг каждого автора:
```sql
SELECT title, author, amount, price
FROM book
WHERE amount < ALL(
		SELECT AVG(amount)
		FROM book
		GROUP BY author
		);
```

Вывести информацию о книгах, цена которых меньше самой большой из минимальных цен, вычисленных для каждого автора.
```sql
SELECT author, title, price
FROM book
WHERE price < ANY(
		SELECT MIN(price)
		FROM book
		GROUP BY author
		);
```

#### Вложенный запрос после SELECT
> Вложенный запрос может располагаться после ключевого слова `SELECT`. В этом случае результат выполнения запроса выводится в отдельном столбце результирующей таблицы.
> 
> Также вложенный запрос может использоваться в выражениях.

Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3,  а также указать среднее значение количества экземпляров книг:
```sql
SELECT title,
	   author,
	   amount,
	   (SELECT AVG(amount) FROM book) AS Среднее_количество_всех_книг
FROM book
WHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;
```
![[Pasted image 20240421150645.png]]
- Т.к. вложенный запрос в `SELECT` подсчитывает среднее кол-во книг по всех таблице, в каждой строке одинаковое значение.

Посчитать сколько и каких экземпляров книг нужно заказать поставщикам, чтобы на складе стало одинаковое количество экземпляров каждой книги, равное значению самого большего количества экземпляров одной книги на складе :
```sql
SELECT title,
	   author,
	   amount,
	   ((SELECT MAX(amount) FROM book) - amount) AS Заказ  
FROM book  
WHERE amount <> (SELECT MAX(amount) FROM book);
```
![[Pasted image 20240421150259.png]]

### 1.5 Запросы корректировки данных
#### Создание пустой таблицы
```sql
CREATE TABLE supply(
	supply_id INT PRIMARY KEY AUTO_INCREMENT,
	title VARCHAR(50),
	author VARCHAR(30),
	price DECIMAL(8,2),
	amount INT
);
```

#### Добавление записей в таблицу
> Добавление записей в таблицу осуществляется с помощью `INSERT`

```sql
INSERT INTO supply(title, author, price, amount)
VALUES
	('Лирика', 'Пастернак Б.Л.', 518.99, 2),
	('Черный человек', 'Есенин С.А.', 570.20, 6),
	('Белая гвардия', 'Булгаков М.А.', 540.50, 7),
	('Идиот', 'Достоевский Ф.М.', 360.80, 3);
```

#### Добавление записей из другой таблицы
> Вместо раздела `VALUES` записывается запрос на выборку, начинающийся с `SELECT`

Правила соответствия между полями таблицы и вставляемыми значениями из запроса:
1) Количество полей в таблице и количество полей в запросе должны совпадать;
2) Порядок столбцов запроса и таблицы - должен совпадать.
3) Типы столбцов запроса должны быть совместимы с типами данных соответствующих столбцов таблицы (целое число можно занести в поле типа `DECIMAL`, обратная операция – недопустима).

```sql
INSERT INTO book (title, author, price, amount)
SELECT title, author, price, amount
FROM supply
WHERE author NOT IN('Булгаков М.А.', 'Достоевский Ф.М.');
```

#### Добавление записей, вложенные запросы
Занести из таблицы `supply` в таблицу `book` только те книги, названия которых отсутствуют в таблице `book`:
```sql
INSERT INTO book (title, author, price, amount)
SELECT title, author, price, amount
FROM supply
WHERE title NOT IN(SELECT title FROM book);
```

#### Запросы на обновление
> Под обновлением данных подразумевается изменение значений в существующих записях таблицы.

```sql
UPDATE таблица SET поле = выражение
```

С помощью ключевое слово `WHERE` в запросе на обновление можно изменять не все записи в таблице, а только часть из них.
```sql
UPDATE book
SET price = 0.9 * price
WHERE amount BETWEEN 5 AND 10;
```

#### Запрос на обновление нескольких столбцов
> Запросом `UPDATE` можно обновлять значения нескольких столбцов одновременно.

```sql
UPDATE таблица SET поле1 = выражение1, поле2 = выражение2
```

В таблице **book** необходимо скорректировать значение для покупателя в столбце **buy** таким образом, чтобы оно не превышало количество экземпляров книг, указанных в столбце **amount**. А цену тех книг, которые покупатель не заказывал, снизить на 10%.
```sql
UPDATE book
SET buy = IF(amount >= buy, buy, amount),
	price = IF(buy = 0, price * 0.9, price)
```

#### Запросы на обновление нескольких таблиц
> В запросах на обновление можно использовать несколько таблиц

Но тогда:
- для столбцов, имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся
- все таблицы, используемые в запросе, нужно перечислить после ключевого слова `UPDATE`
- в запросе обязательно условие `WHERE`, в котором указывается условие при котором обновляются данные

Для тех книг, в таблице `book` , которые есть в таблице `supply`, увеличить их количество в таблице `book` и пересчитать их цену:
```sql
UPDATE book, supply
SET book.amount = book.amount + supply.amount,
book.price = (book.price + supply.price)/2
WHERE book.title = supply.title AND book.author = supply.author;
```

#### Запросы на удаление
```sql
DELETE FROM таблица;

DELETE FROM таблица
WHERE условие;
```

Удалить из таблицы `supply` книги тех авторов, общее количество экземпляров книг которых в таблице `book` превышает 10:
```sql
DELETE FROM supply
WHERE author IN(SELECT author
				FROM book
				GROUP BY author
				HAVING SUM(amount) > 10
			 );
```

#### Запросы на создание таблицы
> Новая таблица может быть создана на основе данных из другой таблицы.
> Для этого используется запрос `SELECT`, результирующая таблица которого и будет новой таблицей базы данных.
> При этом имена столбцов запроса становятся именами столбцов новой таблицы.

```sql
CREATE TABLE имя_таблицы AS
SELECT ...
```

Создать таблицу заказ (`ordering`), куда включить авторов и названия тех книг, количество экземпляров которых в таблице `book` меньше 4. Для всех книг указать одинаковое количество экземпляров 5.
```sql
CREATE TABLE ordering AS
	SELECT author, title, 5 AS amount
	FROM book
	WHERE amount < 4;
```

Создать таблицу заказ (`ordering`), куда включить авторов и названия тех книг, количество экземпляров которых в таблице `book` меньше среднего количества экземпляров книг в таблице `book`. В таблицу включить столбец  `amount`, в котором для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице `book`:
```sql
CREATE TABLE ordering AS
SELECT author, title, (SELECT ROUND(AVG(amount)) FROM book) AS amount
WHERE amount < (SELECT ROUND(AVG(amount)) FROM book)
```

### 1.6 
#### Оператор LIMIT
> Для ограничения вывода записей в SQL используется оператор `LIMIT` , после которого указывается количество строк. 
> Результирующая таблица будет иметь количество строк не более указанного после `LIMIT`.
> `LIMIT` размещается после раздела `ORDER BY`.

Как правило, этот оператор используется, чтобы отобрать заданное количество отсортированных строк результата запроса.

Вывести информацию о первой  командировке из таблицы `trip`:
```sql
SELECT *
FROM trip
ORDER BY date_first
LIMIT 1;
```

<font style="color:red">ВАЖНО</font>: Оператор `LIMIT` нужно использовать очень осторожно. Например, если бы в таблице `trip` было несколько командировок с одинаковой датой начала, этот запрос работал бы НЕВЕРНО. Это связано с тем, что заранее не известно точное значение таких командировок.

#### Функции по работе с датами
##### Функция DATEDIFF()
> Для вычитания двух дат используется функция `DATEDIFF(дата_1, дата_2)`, результатом которой является количество дней между **дата_1** и **дата_2**.

Примеры:
`DATEDIFF('2020-04-01', '2020-03-28')=4`
`DATEDIFF('2020-05-09','2020-05-01')=8`

```sql
SELECT name, city, (DATEDIFF(date_last, date_first) + 1) AS Длительность_командировки
FROM trip;
```

##### Функция DAY()
`DAY('2020-02-01') = 1`

##### Функция MONTH()
> Для того, чтобы выделить номер месяца из даты используется функция `MONTH(дата)`

`MONTH('2020-04-12') = 4`

##### Функция YEAR()
`YEAR('2020-02-01') = 2020`

##### Функция MONTHNAME()
> Для вычисления название месяца из даты используется функция `MONTHNAME(дата)`, которая возвращает название месяца на английском языке для указанной даты.

`MONTHNAME('2020-04-12')='April'`

Вывести название месяца и количество командировок для каждого месяца. Считаем, что командировка относится к некоторому месяцу, если она началась в этом месяце:
```sql
SELECT MONTHNAME(date_first) AS Месяц, COUNT(*) AS Количество
FROM trip
GROUP BY MONTHNAME(date_first)
/* GROUP BY Месяц */
ORDER BY Количество DESC, Месяц;
```

- Если группировка осуществляется по вычисляемому столбцу (в данном случае «вычисляется» название месяца), то после `GROUP BY`можно указать как вычисляемое выражение, так и имя столбца, заданное с помощью `AS`.
  <font style="color:red">Важно отметить</font>, что последний вариант (указать имя столбца)  нарушает стандарт по порядку выполнения запросов, но иногда может встречаться на реальных платформах.

##### Пример разбора работы HAVING
Вывести фамилию с инициалами и общую сумму суточных, полученных за все командировки для тех сотрудников, которые были в командировках больше чем 3 раза, в отсортированном по убыванию сумм суточных виде:
```sql
SELECT name, SUM((DATEDIFF(date_last, date_first) + 1) * per_diem) AS Сумма  
FROM trip  
GROUP BY name  
HAVING COUNT(*) > 3  
ORDER BY Сумма DESC;
```

> `HAVING` фильтрует группы строк, а не индивидуальные строки.
> В приведенном примере строки группируются по столбцу `name`.
> При этом после группировки, в каждой группе может оказаться по несколько строк. `HAVING` работает со всеми строками, попавшими в группу.
> 
> Как в приведенном примере, условие `HAVING COUNT(*) > 3` проверяет, что в группу попало более 3 записей => сотрудник был в командировках более 3 раз.

### 1.7
#### Использование временного имени таблицы (алиаса)
> Алиас - это псевдоним, который мы присваивали столбцам или таблицам после ключевого слова `AS`

Два способа присваивания псевдонима:
- с использованием ключевого слова `AS`
```sql
FROM fine AS f, traffic_violation AS tv
```
- и без него
```sql
FROM fine f, traffic_violation tv
```

Пример:
```sql
UPDATE fine AS f, traffic_violation tv
SET f.sum_fine = tv.sum_fine
WHERE f.violation = tv.violation AND f.sum_fine IS NULL;
```

#### Группировка данных по нескольким столбцам
> В разделе `GROUP BY` можно указывать несколько столбцов, разделяя их запятыми. Тогда к одной группе будут относиться записи, у которых значения столбцов, входящих в группу, равны.

```sql
SELECT name, number_plate, violation, count(*)
FROM fine
GROUP BY name, number_plate, violation;
```
![[Pasted image 20240515173633.png]]
- Записи таблицы **`fine`** разделяются на группы.
  В каждую группу включаются строки, у которых равны значения в столбцах `name`, `number_plate` и `violation`.

<font style="color:red">ВАЖНО</font>: В разделе `GROUP BY` нужно перечислять все НЕАГРЕГИРОВАННЫЕ столбцы (к которым не применяются групповые функции) из `SELECT`

В таблице `fine` увеличить в два раза сумму неоплаченных штрафов для тех водителей, которые на одной машине нарушили одно и то же правило два и более раз.
```sql
UPDATE fine f,
	   (SELECT name, number_plate, violation
	   FROM fine
	   GROUP BY name, number_plate, violation
	   HAVING COUNT(violation) >= 2) AS query_f
	   /*Тут важно заключать вложенный запрос в скобки ()*/
SET sum_fine = sum_fine * 2
WHERE date_payment IS NULL
	  AND f.name = query_f.name
	  AND f.number_plate = query_f.number_plate
	  AND f.violation = query_f.violation;
```


## Запросы SQL к связанным таблицам
### 2.1 Связи между таблицами
#### One-to-Many
> Связь «**один ко многим**» имеет место, когда одной записи главной таблицы соответствует несколько записей связанной таблицы, а каждой записи связанной таблицы соответствует только одна запись главной таблицы.

Рассмотрим связь one-to-many на примере таблиц `book` и `author` (с условием, что <font style="color:red">у одной книги может быть только один автор</font>):
![[Pasted image 20240516193841.png]]
- таблица `author` называется главной (<font style="color:red">one</font>),
  таблица `book` – связанной или подчиненной (<font style="color:red">many</font> - `FK` всегда находится тут).
- В связанной таблице (`book`), связанный столбец (внешний ключ, `FOREIGN KEY`) должен соответствовать по типу ключевому столбцу (`author_id`) главной таблицы (`author`).

#### Many-to-many
> Связь «**многие ко многим**» имеет место когда каждой записи одной таблицы соответствует несколько записей во второй, и наоборот, каждой записи второй таблицы соответствует несколько записей в первой.

Рассмотрим связь many-to-many на примере таблиц `book` и `author` (Один автор может написать несколько книг, а одна книга может быть написана несколькими авторами) :
![[Pasted image 20240516200344.png]]
- для установления связи many-to-many для двух таблиц используется третья, связывающая, таблица, состоящая из двух столбцов (`FK` ссылающиеся на `PK` связываемых таблиц, которые должны совпадать по типу данных).

#### Создание таблицы с внешними ключами (FK)
При создании зависимой таблицы (таблицы, которая содержит `FK`) необходимо учитывать:
- каждый внешний ключ должен иметь такой же тип данных, как связанное поле главной таблицы (`PK`).
- необходимо указать главную для нее таблицу и столбец, по которому осуществляется связь:
```sql
FOREIGN KEY (связанное_поле_зависимой_таблицы)
REFERENCES главная_таблица (связанное_поле_главной_таблицы)
```

<br>
По умолчанию любой столбец, кроме ключевого, может содержать значение `NULL`. При создании таблицы это можно переопределить,  используя  ограничение `NOT NULL` для этого столбца:

```sql
CREATE TABLE таблица(
	столбец_1 INT NOT NULL,
	столбец_2 VARCHAR(10)
	);
```

- для `FK` рекомендуется устанавливать ограничение `NOT NULL` (<font style="color:red">НО все зависит от бизнес логики</font>).

```sql
CREATE TABLE book(
book_id INT PRIMARY KEY AUTO_INCREMENT,
title VARCHAR(50),
author_id INT NOT NULL,
genre_id INT,
price DECIMAL(8, 2),
amount INT,
FOREIGN KEY (author_id) REFERENCES author (author_id),
FOREIGN KEY (genre_id) REFERENCES genre (genre_id)
);
```

#### Действия при удалении записи главной таблицы
> С помощью выражения `ON DELETE` можно установить **действия**, которые выполняются для записей подчиненной таблицы **при удалении связанной строки из главной таблицы**.

При удалении можно установить следующие опции:
- `CASCADE`: автоматически удаляет строки из зависимой таблицы при удалении связанных строк в главной таблице.
- `SET NULL`: при удалении  связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение **`NULL`**. (В этом случае столбец внешнего ключа должен поддерживать установку `NULL`).
- `SET DEFAULT` похоже на `SET NULL` за тем исключением, что значение  внешнего ключа устанавливается не в `NULL,` а в значение по умолчанию для данного столбца.
- `RESTRICT`: отклоняет удаление строк в главной таблице при наличии связанных строк в зависимой таблице.

```sql
CRATE TABLE book(
book_id INT PRIMARY KEY AUTO_INCREMENT,
title VARCHAR(50),
author_id INT NOT NULL,
genre_id INT,
price DECIMAL(8, 2),
amount INT,
FOREIGN KEY (author_id) REFERENCES author (author_id) ON DELETE CASCADE,
FOREIGN KEY (genre_id) REFERENCES genre (genre_id) ON DELETE SET NULL
);
```

### 2.2 Запросы на выборку, соединение таблиц
