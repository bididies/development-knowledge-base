> [Course](https://stepik.org/course/63054/promo)

### Тренажеры
[sqlbolt](https://sqlbolt.com/)  
[sql-ex](https://sql-ex.ru/)

## 1. Основы реляционной модели и SQL
### 1.1 Таблица
#### Теоретические тезисы
- Название таблицы в DB - существительное в единственном числе.  
Рекомендуется использовать только строчные (маленькие) буквы (это касается и наименований столбцов).  
- В названии таблиц и столбцов допускаются только: буквы, цифры и `_` 
- Шаблон имени для PK: `tablename_id`.  
- SQL не является регистро-зависимым языком, но рекомендуется писать ключевые слова прописными (большими), а наименования строчными (маленькими) буквами.

#### Типы данных

|**Тип данных**|**Описание**|**Пример**|
|---|---|---|
|`INT`   <br>`INTEGER`|Целое число, могут принимать значения  <br>от -2 147 483 648 до 2 147 483 647|-567  <br>1205|
|`DECIMAL`  <br>`NUMERIC`|Вещественное число,  <br>в скобках указывается максимальная  <br>длина числа (включает символы слева и справа от десятичной запятой)  <br>и количество знаков после запятой.  <br>Можно использовать оба этих типа, они эквивалентны,  <br>принимают значения в диапазоне -1038+1 до 1038-1.  <br>`DECIMAL(4,1)    NUMERIC(6,3)`|34.6  <br>-3.294|
|`DATE`|Дата в формате ГГГГ-ММ-ДД   <br>_26 июля 2020 года  <br>3 января 2021 года_|2020-07-26  <br>2021-01-03|
|`VARCHAR`|Строка длиной не более 255 символов, <br>в скобках указывается максимальная  <br>длина строки, которая может храниться в поле <br>`VARCHAR(10)(рассматриваются однобайтовые кодировки, для которых число в скобках соответствует максимальному   количеству символов в строке)`|пример  <br>описание|
#### Создание таблицы
```sql
CREATE TABLE book(
book_id INT PRIMARY KEY AUTO_INCREMENT,
title VARCHAR(50),
author VARCHAR(30),
price DECIMAL(8, 2),
amount INT
);
```

#### Добавление данных в таблицу
```sql
INSERT INTO book (title, author, price, amount)
VALUES ('Мастер и Маргарита', 'Булгаков М.А.', 670.99, 3);

INSERT INTO book (title, author, price, amount)
VALUES
('Белая гвардия', 'Булгаков М.А.', 540.5, 5),
('Идиот', 'Достоевский Ф.М.', 460, 10),
('Братья Карамазовы', 'Достоевский Ф.М.', 799.01, 2);
```

### 1.2 Выборка данных
#### Выборки из таблицы
```sql
SELECT * FROM book;
SELECT author, title, price FROM book;
```
> Выборка с заданием новых имен столбцам при отображении (новое имя может быть написано кириллицей, главное без пробелов):
```sql
SELECT title AS Название, author AS Автор, amount
FROM book;
```
![[Pasted image 20240325181016.png]]

> Выборка с созданием нового вычисляемого столбца при отображении:
```sql
SELECT title, author, price, amount, price * amount AS total
FROM book;

SELECT title, amount, amount * 1.65 AS pack
FROM book;
```
Для вычисляемого столба в списки полей **указывается выражение** (может включать: имена столбцов, константы, знаки операций, встроенные ф-ии) и **задается имя**.

#### Математические ф-ии в SQL
|**Функция**|**Описание**|**Пример**|
|---|---|---|
|`CEILING(x)`|возвращает наименьшее целое число, большее или равное **x**  <br>(округляет до целого числа в большую сторону)|`CEILING(4.2) = 5   CEILING(-5.8) = -5`|
|`ROUND(x,k)`|округляет значение **x** до **k** знаков после запятой,  <br>если **k** не указано – **x** округляется до целого|`ROUND(4.361) = 4   ROUND(5.86592, 1) = 5.9`|
|`FLOOR(x)`|возвращает наибольшее целое число, меньшее или равное **x**  <br>(округляет до  целого числа в меньшую сторону)|`FLOOR(4.2) = 4` <br>`FLOOR(-5.8) = -6`|
|`POWER(x,y)`|возведение **x** в степень **y**|`POWER(3, 4) = 81.0`|
|`SQRT(x)`|квадратный корень из **x**|`SQRT(4) = 2.0` <br>`SQRT(2) = 1.41...`|
|`DEGREES(x)`|конвертирует значение **x** из радиан в градусы|`DEGREES(3) = 171.8...`|
|`RADIANS(x)`|конвертирует значение **x** из градусов в радианы|`RADIANS(180) = 3.14...`|
|`ABS(x)`|модуль числа **x**|`ABS(-1) = 1` <br>`ABS(1) = 1`|
|`PI()`|pi = 3.1415926...||

Пример запроса :
```sql
SELECT title,
       author,
       amount,
       ROUND(price * 0.7, 2) AS new_price
FROM book;
```
![[Pasted image 20240327223826.png]]

#### Логические ф-ии

> `IF(expression, выражение_1, выражение_2)`
> 
> Функция вычисляет `expression`,
> если оно `true` – возвращается  `выражение_1`, если `false` –  `выражение_2`
> 
> Все три параметра `IF()` являются обязательными.
> вместо `выражение_1` или `выражение_2` может стоять новая функция `IF()`

Примеры запросов :
```sql
SELECT title, amount, price,
ROUND(IF(amount < 4, price * 0.5, price * 0.7), 2) AS sale
FROM book;
```
![[Pasted image 20240328171119.png]].

```sql
SELECT author, title, price,
ROUND(IF(author = 'Булгаков М.А.',
		 price * 1.1,
		 IF(author = 'Есенин С.А.', price * 1.05, price)), 2) AS new_price  
FROM book;
```
![[Pasted image 20240328170927.png]]

#### Выборка данных по условию
> С помощью ключевого слова `WHERE` можно включать в итоговую выборку только те строки, которые отвечают некоторому условию.
> 
> Ключевое слово `WHERE` используется после указания таблицы.
> 
> Логическое выражение может включать **операторы сравнения** (равно «**=**», не равно «**<>**», больше «**>**», меньше «**<**», больше или равно«**>=**», меньше или равно «**<=**») и выражения, допустимые в SQL.

Примеры запросов :
```sql
SELECT author, title, price  
FROM book  
WHERE amount < 10;
```

> В логическом выражении после `WHERE` нельзя использовать названия столбцов, присвоенные им с помощью `AS`,  так как при выполнении запроса сначала вычисляется логическое выражение для каждой строки исходной таблицы, выбираются строки, для которых оно истинно. А только после этого формируется "шапка запроса" – столбцы, включаемые в запрос.
```sql
SELECT title, author, price * amount AS total
FROM book
WHERE price * amount > 4000;
```

##### Логические операции
После ключевого слова `WHERE` могут использоваться:
- операторы сравнения
- выражения (`IN`, `BETWEEN`)
- **логические операции** (И «**and**», ИЛИ «**or**», НЕ «**not**») и круглые скобки, изменяющие приоритеты выполнения операций.

Приоритеты операций:
1. круглые скобки
2. умножение  (*),  деление (/)
3. сложение  (+), вычитание (-)
4. операторы сравнения (=, >, <, >=, <=, <>)
5. NOT
6. AND
7. OR

Примеры запросов :
```sql
SELECT title, author, price
FROM book
WHERE price > 600 AND author = 'Булгаков М.А.';
```

```sql
SELECT title, author, price, amount  
FROM book  
WHERE (price > 600 OR price < 500) AND price * amount >= 5000;
```

##### Операторы IN, BETWEEN
> Приоритет у этих операторов такой же, как у операторов сравнения (`=`, `>`, `<`, `>=`, `<=`, `<>`)

> `BETWEEN` позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.

```sql
SELECT title, amount
FROM book
WHERE amount BETWEEN 5 AND 14;
```
Аналогичный запрос:
```sql
SELECT title, amount
FROM book
WHERE amount >= 5 AND amount <=14;
```

> `IN` позволяет выбрать данные, соответствующие значениям из списка.

```sql
SELECT title, price
FROM book
WHERE author IN ('Булгаков М.А.', 'Достоевский Ф.М.');
```
Аналогичный запрос:
```sql
SELECT title, price
FROM book

WHERE author = 'Булгаков М.А.' OR author = 'Достоевский Ф.М.';
```

#### Сортировка
> `ORDER BY` позволяет сортировать выборку данных по одному  или нескольким столбцам

При этом, если указано два столбца, строки всегда сортируются только по первому столбцу, сортировка по второму осуществляется только для строк, у которых значения первых столбцов одинаковые.<br>
По умолчанию `ORDER BY` выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки вручную после имени столбца(-ов) ставится ключевое слово:
 - `ASC` - по возрастанию
 - `DESC` - по убыванию

Синтаксис:
```sql
SELECT *
FROM table_name
WHERE column_1 > 500
ORDER BY column_1, column_2 DESC
```

Столбцы после ключевого слова `ORDER BY` можно задавать:
- названием столбца
- номером столбца
- именем столбца (указанным после `AS`)

Примеры:

```sql
SELECT title, author, price
FROM book
ORDER BY title;

Аналогичный запрос:

SELECT title, author, price
FROM book
ORDER BY 1;
```

<br>
Разберем данный пример подробнее:

```sql
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, amount DESC;

Другие варианты записи запроса:

SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, Количество DESC;

SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY 1, 3 DESC;

```

![[Pasted image 20240331143725.png]]

1. Сортировка осуществляется по первому столбцу (`author`).
   Ключевое слово `DESC` относится только ко второму столбцу, по этому тут оно не учитывается.
2. Строки с одинаковыми первыми столбцами сортируются по второму столбцу в обратном порядке.

#### Оператор LIKE
> `LIKE` используется для сравнения строк в соответствии с указанным шаблоном, а не на полное совпадение/не совпадение.

Шаблон может включать **обычные символы** и **символы-шаблоны**

|**Символ-шаблон**|**Описание**|
|---|---|
|**%**|Любая строка, содержащая ноль или более символов|
|**_** (подчеркивание)|Любой одиночный символ|

Синтаксис:
```sql
SELECT *
FROM table_name
WHERE column_1 LIKE 'Б%'
/* эквивалентное условие column_1 LIKE 'б%' */
```
- шаблон не зависит от регистра.

Примеры:
1. Выбрать все `book` с `title` из 5 символов
```sql
SELECT title
FROM book
WHERE title LIKE "_____"
```

2. Выбрать все `book` в `title` которых нет ни одного пробела
```sql
SELECT title
FROM book
WHERE title NOT LIKE "% %";
```

### 1.3 Запросы, групповые операции
#### Выбор уникальных элементов столбца
> Ключевое слово `DISTINCT` используется для отбора уникальных эл-тов столбца.
> `DISTINCT` размещается сразу после `SELECT`

Пример запроса:
```sql
SELECT DISTINCT author
FROM book;
```

Такого же результата можно добиться с помощью оператора `GROUP BY` (но прям для такого же результата необходимо и группировать и выбирать по одному, нужному столбцу):
```sql
SELECT author
FROM book
GROUP BY author;
```

> `DISTINCT` можно применять к столбцам внутри sql ф-ий

```sql
SELECT author, SUM(DISTINCT price)  
FROM book  
GROUP BY author;
```


#### Выборка данных, групповые ф-ии
##### SUM и COUNT
> При группировке элементов столбца эл-ты, входящие в каждую группу, можно просуммировать или подсчитать их кол-во.

<font style="color:red">ВАЖНО</font>: если столбец указан в `GROUP BY`, то он должен быть указан и в `SELECT`.

Пример запроса:
```sql
SELECT author, SUM(amount), COUNT(amount)
FROM book
GROUP BY author;
```
 
 > Ф-ию `COUNT` можно применять к любому столбцу, в том числе и использовать `*`.
 > Если столбец, по которому производится подсчет ф-ей `COUNT` имеет значение `null` - данное значение не будет учтено.
 > 
 > `COUNT(*)` - подсчитывает все записи, относящиеся к группе, в том числе и со значением `null`.
 
Пример данных таблицы подобного кейса:
![[Pasted image 20240413012711.png]]

```sql
SELECT author, COUNT(author), COUNT(amount) AS Количество_книг, COUNT(*)
FROM book
GROUP BY author;
```

![[Pasted image 20240420135855.png]]
- Название столбцов (указываемое через `AS`) может состоять из нескольких слов, тогда их нужно заключать в кавычки. Но если слова написать через подчеркивание, тогда получится , что название состоит из одного слова, и кавычки можно не ставить.

##### MIN, MAX, AVG
> К групповым функциям SQL относятся: `MIN()`, `MAX()` и `AVG()`, которые вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.

```sql
SELECT author, MIN(price) AS min_prise
FROM book
GROUP BY author;
```

##### Выборка с вычислением
> В качестве аргумента групповых функций  SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение.
> А так же групповые функции могут быть элементами выражений.

```sql
SELECT author, SUM(price * amount) AS Стоимость_всех_книг
FROM book
GROUP BY author;

SELECT author, ROUND(AVG(price), 2) AS Средняя_цена
FROM book
GROUP BY author;
```

- Имена столбцов, присвоенные им с помощью `AS`, нельзя использовать в выражениях, только названия столбцов исходной таблицы.
```sql
SELECT author,  
ROUND(SUM(price * amount), 2) AS Стоимость,  
ROUND(SUM(price * amount) * 18 / 118, 2) AS НДС,  
ROUND(SUM(price * amount) * 100 / 118, 2) AS Стоимость_без_НДС  
FROM book  
GROUP BY author;
```

#### Вычисления по таблице целиком
> Групповые функции позволяют вычислять итоговые значения по всей таблице.
> После ключевого слова `SELECT` указывается групповая функция для выражения или имени столбца, а ключевые слова `GROUP BY` опускаются.

```sql
SELECT SUM(amount) AS Количество, SUM(price * amount) AS Стоимость
FROM book;
```
 - Результатом таких запросов является единственная строка с вычисленными по таблице значениями.
![[Pasted image 20240413200129.png]]

#### Выборка данных по условию
> В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после `WHERE`. В запросах с групповыми функциями вместо `WHERE` используется ключевое слово `HAVING` , которое размещается после оператора `GROUP BY`.

```sql
SELECT author,
       MIN(price) AS Минимальная_цена,
       MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000;
```

- Также в запросах с группировкой можно сортировать данные:
```sql
SELECT author,
       MIN(price) AS Минимальная_цена,
       MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000
ORDER BY Минимальная_цена DESC;
```

- Если в запросе с групповыми функциями отсутствует `GROUP BY`, то для отбора записей используется ключевое слово `WHERE`.

```sql
SELECT ROUND(AVG(price), 2) AS Средняя_цена
FROM book
WHERE amount BETWEEN 5 AND 14;
```

##### WHERE и HAVING
> `WHERE` и `HAVING` могут использоваться в одном запросе.

 При этом необходимо учитывать **порядок выполнения  SQL запроса на выборку на СЕРВЕРЕ**:
1. FROM
2. WHERE
3. GROUP BY
4. HAVING
5. SELECT
6. ORDER BY

> 1. Сначала определяется таблица, из которой выбираются данные (`FROM`).
> 2. Затем из этой таблицы отбираются записи в соответствии с условием  `WHERE`.
> 3. Выбранные данные агрегируются (`GROUP BY`).
> 4. Из агрегированных записей выбираются те, которые удовлетворяют условию после `HAVING`.
> 5. Потом формируются данные результирующей выборки, как это указано после `SELECT` ( вычисляются выражения, присваиваются имена и пр. ).
> 6. Результирующая выборка сортируется, как указано после `ORDER BY`.

<font style="color:red">ВАЖНО</font>:
Порядок ВЫПОЛНЕНИЯ запросов - это не порядок ЗАПИСИ ключевых слов в запросе на выборку.
Порядок записи (синтаксис запроса) остается таким же, как рассматривался ранее.
Порядок ВЫПОЛНЕНИЯ  нужен для того, чтобы понять, почему, например, в `WHERE` нельзя использовать имена выражений из `SELECT`. Просто `SELECT` выполняется компилятором позже, чем `WHERE`, поэтому ему неизвестно, какое там выражение написано

```sql
SELECT author,
       MIN(price) AS Минимальная_цена,
       MAX(price) AS Максимальная_цена
FROM book
WHERE author <> 'Есенин С.А.'
GROUP BY author
HAVING SUM(amount) > 10;
```

Запрос с аналогичным результатом:
```sql
SELECT author,
       MIN(price) AS Минимальная_цена,
       MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(amount) > 10 AND author <> 'Есенин С.А.';
```
- Но это менее эффективный запрос, так как мы выберем всех авторов из таблицы, сгруппируем по ним, и только после этого уберем `Есенина`. 
  А могли бы изначально не выбирать его из таблицы.
- Всевозможные фильтры лучше ставить как можно раньше.

### 1.4 Вложенные запросы
Вложенный запрос может включать в себя следующие компоненты:
- Обязательные: `SELECT`, `FROM`
- Не обязательные: `WHERE`, `GROUP BY`, `HAVING`

Вложенные запросы могут использоваться после `WHERE`, `HAVING`, а так же `SELECT`.

#### Вложенный запрос, возвращающий одно значение
```sql
SELECT title, author, price, amount
FROM book
WHERE price = (SELECT MIN(price) FROM book);

SELECT author, title, price
FROM book
WHERE price <= (SELECT AVG(price) FROM book)
ORDER BY price DESC;
```

#### Использование вложенного запроса в выражении
> Вложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд.

Вывести inf-ю о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на `3` :
```sql
SELECT title, author, amount
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) > 3;
```

Вывести книги, цены которых превышают минимальную цену книги на складе не более чем на 150 рублей в отсортированном по возрастанию цены виде:
```sql
SELECT author, title, price
FROM book
WHERE (price - (SELECT MIN(price) FROM book)) BETWEEN 0 AND 150
ORDER BY price;
```

#### Вложенный запрос, оператор IN
> Вложенный запрос может возвращать несколько значений одного столбца. 
> Тогда его можно использовать в разделе `WHERE` совместно с оператором `IN` :

```sql
WHERE имя_столбца IN (вложенный запрос, возвращающий ОДИН СТОЛБЕЦ)
```

- Оператор `IN` определяет, совпадает ли значение столбца с одним из значений, содержащихся во вложенном запросе.
- Оператор `NOT IN` выполняет обратное действие.

Вывести inf-ю о книгах тех авторов, общее количество экземпляров книг которых не менее 12 :
```sql
SELECT title, author, amount, price
FROM book
WHERE author IN(
		SELECT author
		FROM book
		GROUP BY author
		HAVING SUM(amount) >= 12
		);
```

Вывести inf-ю о книгах, количество экземпляров которых в таблице `book` не дублируется :
```sql
SELECT author, title, amount
FROM book
WHERE amount IN(
		SELECT amount
		FROM book
		GROUP BY amount
		HAVING COUNT(amount) = 1
		/* HAVING COUNT(*) = 1 - можно и так
		*/
		);
```

#### Вложенный запрос, операторы ANY и ALL
> Операторы `ANY` и `ALL` используются  в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца.
> 
> Операторы `ANY` и `ALL` используются совместно с операциями отношения (=, <>, <=, >=, <, >)
> 
> Операторы `ALL` и `ANY` можно использовать **только со вложенными запросами**.

**ANY** -  в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно <font style="color:red">хотя бы для одного элемента</font> результирующего (вложенного) запроса.

- `amount > ANY (10, 12)` эквивалентно `amount > 10`
- `amount < ANY (10, 12)` эквивалентно `amount < 12`
- `amount = ANY (10, 12)` эквивалентно `(amount = 10) OR (amount = 12)`, а также `amount IN  (10,12)`
- `amount <> ANY (10, 12)` вернет все записи с любым значением `amount,` включая 10 и 12, так как эквивалентно `(amount <> 10) OR (amount <> 12)` 

**ALL** - в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно <font style="color:red">для всех элементов</font> результирующего запроса.

- `amount > ALL (10, 12)` эквивалентно `amount > 12`
- `amount < ALL (10, 12)` эквивалентно `amount < 10`
- `amount = ALL (10, 12)` не вернет ни одной записи, так как эквивалентно `(amount = 10) AND (amount = 12)`
- `amount <> ALL (10, 12)` вернет все записи кроме тех,  в которых`amount равно 10 или 12`

Вывести информацию о тех книгах, количество которых меньше самого маленького среднего количества книг каждого автора:
```sql
SELECT title, author, amount, price
FROM book
WHERE amount < ALL(
		SELECT AVG(amount)
		FROM book
		GROUP BY author
		);
```

Вывести информацию о книгах, цена которых меньше самой большой из минимальных цен, вычисленных для каждого автора.
```sql
SELECT author, title, price
FROM book
WHERE price < ANY(
		SELECT MIN(price)
		FROM book
		GROUP BY author
		);
```

#### Вложенный запрос после SELECT
> Вложенный запрос может располагаться после ключевого слова `SELECT`. В этом случае результат выполнения запроса выводится в отдельном столбце результирующей таблицы.
> 
> Также вложенный запрос может использоваться в выражениях.

Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3,  а также указать среднее значение количества экземпляров книг:
```sql
SELECT title,
	   author,
	   amount,
	   (SELECT AVG(amount) FROM book) AS Среднее_количество_всех_книг
FROM book
WHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;
```
![[Pasted image 20240421150645.png]]
- Т.к. вложенный запрос в `SELECT` подсчитывает среднее кол-во книг по всех таблице, в каждой строке одинаковое значение.

Посчитать сколько и каких экземпляров книг нужно заказать поставщикам, чтобы на складе стало одинаковое количество экземпляров каждой книги, равное значению самого большего количества экземпляров одной книги на складе :
```sql
SELECT title,
	   author,
	   amount,
	   ((SELECT MAX(amount) FROM book) - amount) AS Заказ  
FROM book  
WHERE amount <> (SELECT MAX(amount) FROM book);
```
![[Pasted image 20240421150259.png]]

### 1.5 Запросы корректировки данных
#### Создание пустой таблицы
```sql
CREATE TABLE supply(
	supply_id INT PRIMARY KEY AUTO_INCREMENT,
	title VARCHAR(50),
	author VARCHAR(30),
	price DECIMAL(8,2),
	amount INT
);
```

#### Добавление записей в таблицу
> Добавление записей в таблицу осуществляется с помощью `INSERT`

```sql
INSERT INTO supply(title, author, price, amount)
VALUES
	('Лирика', 'Пастернак Б.Л.', 518.99, 2),
	('Черный человек', 'Есенин С.А.', 570.20, 6),
	('Белая гвардия', 'Булгаков М.А.', 540.50, 7),
	('Идиот', 'Достоевский Ф.М.', 360.80, 3);
```

#### Добавление записей из другой таблицы
> Вместо раздела `VALUES` записывается запрос на выборку, начинающийся с `SELECT`

Правила соответствия между полями таблицы и вставляемыми значениями из запроса:
1) Количество полей в таблице и количество полей в запросе должны совпадать;
2) Порядок столбцов запроса и таблицы - должен совпадать.
3) Типы столбцов запроса должны быть совместимы с типами данных соответствующих столбцов таблицы (целое число можно занести в поле типа `DECIMAL`, обратная операция – недопустима).

```sql
INSERT INTO book (title, author, price, amount)
SELECT title, author, price, amount
FROM supply
WHERE author NOT IN('Булгаков М.А.', 'Достоевский Ф.М.');
```

#### Добавление записей, вложенные запросы
Занести из таблицы `supply` в таблицу `book` только те книги, названия которых отсутствуют в таблице `book`:
```sql
INSERT INTO book (title, author, price, amount)
SELECT title, author, price, amount
FROM supply
WHERE title NOT IN(SELECT title FROM book);
```

#### Запросы на обновление
> Под обновлением данных подразумевается изменение значений в существующих записях таблицы.

```sql
UPDATE таблица SET поле = выражение
```

С помощью ключевое слово `WHERE` в запросе на обновление можно изменять не все записи в таблице, а только часть из них.
```sql
UPDATE book
SET price = 0.9 * price
WHERE amount BETWEEN 5 AND 10;
```

#### Запрос на обновление нескольких столбцов
> Запросом `UPDATE` можно обновлять значения нескольких столбцов одновременно.

```sql
UPDATE таблица SET поле1 = выражение1, поле2 = выражение2
```

В таблице **book** необходимо скорректировать значение для покупателя в столбце **buy** таким образом, чтобы оно не превышало количество экземпляров книг, указанных в столбце **amount**. А цену тех книг, которые покупатель не заказывал, снизить на 10%.
```sql
UPDATE book
SET buy = IF(amount >= buy, buy, amount),
	price = IF(buy = 0, price * 0.9, price)
```

#### Запросы на обновление нескольких таблиц
> В запросах на обновление можно использовать несколько таблиц

Но тогда:
- для столбцов, имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся
- все таблицы, используемые в запросе, нужно перечислить после ключевого слова `UPDATE`
- в запросе обязательно условие `WHERE`, в котором указывается условие при котором обновляются данные

Для тех книг, в таблице `book` , которые есть в таблице `supply`, увеличить их количество в таблице `book` и пересчитать их цену:
```sql
UPDATE book, supply
SET book.amount = book.amount + supply.amount,
book.price = (book.price + supply.price)/2
WHERE book.title = supply.title AND book.author = supply.author;
```

#### Запросы на удаление
```sql
DELETE FROM таблица;

DELETE FROM таблица
WHERE условие;
```

Удалить из таблицы `supply` книги тех авторов, общее количество экземпляров книг которых в таблице `book` превышает 10:
```sql
DELETE FROM supply
WHERE author IN(SELECT author
				FROM book
				GROUP BY author
				HAVING SUM(amount) > 10
			 );
```

#### Запросы на создание таблицы
> Новая таблица может быть создана на основе данных из другой таблицы.
> Для этого используется запрос `SELECT`, результирующая таблица которого и будет новой таблицей базы данных.
> При этом имена столбцов запроса становятся именами столбцов новой таблицы.

```sql
CREATE TABLE имя_таблицы AS
SELECT ...
```

Создать таблицу заказ (`ordering`), куда включить авторов и названия тех книг, количество экземпляров которых в таблице `book` меньше 4. Для всех книг указать одинаковое количество экземпляров 5.
```sql
CREATE TABLE ordering AS
	SELECT author, title, 5 AS amount
	FROM book
	WHERE amount < 4;
```

Создать таблицу заказ (`ordering`), куда включить авторов и названия тех книг, количество экземпляров которых в таблице `book` меньше среднего количества экземпляров книг в таблице `book`. В таблицу включить столбец  `amount`, в котором для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице `book`:
```sql
CREATE TABLE ordering AS
SELECT author, title, (SELECT ROUND(AVG(amount)) FROM book) AS amount
WHERE amount < (SELECT ROUND(AVG(amount)) FROM book)
```

### 1.6 
#### Оператор LIMIT
> Для ограничения вывода записей в SQL используется оператор `LIMIT` , после которого указывается количество строк. 
> Результирующая таблица будет иметь количество строк не более указанного после `LIMIT`.
> `LIMIT` размещается после раздела `ORDER BY`.

Как правило, этот оператор используется, чтобы отобрать заданное количество отсортированных строк результата запроса.

Вывести информацию о первой  командировке из таблицы `trip`:
```sql
SELECT *
FROM trip
ORDER BY date_first
LIMIT 1;
```

<font style="color:red">ВАЖНО</font>: Оператор `LIMIT` нужно использовать очень осторожно. Например, если бы в таблице `trip` было несколько командировок с одинаковой датой начала, этот запрос работал бы НЕВЕРНО. Это связано с тем, что заранее не известно точное значение таких командировок.

#### Функции по работе с датами
##### Функция DATEDIFF()
> Для вычитания двух дат используется функция `DATEDIFF(дата_1, дата_2)`, результатом которой является количество дней между **дата_1** и **дата_2**.

Примеры:
`DATEDIFF('2020-04-01', '2020-03-28')=4`
`DATEDIFF('2020-05-09','2020-05-01')=8`

```sql
SELECT name, city, (DATEDIFF(date_last, date_first) + 1) AS Длительность_командировки
FROM trip;
```

##### Функция DAY()
`DAY('2020-02-01') = 1`

##### Функция MONTH()
> Для того, чтобы выделить номер месяца из даты используется функция `MONTH(дата)`

`MONTH('2020-04-12') = 4`

##### Функция YEAR()
`YEAR('2020-02-01') = 2020`

##### Функция MONTHNAME()
> Для вычисления название месяца из даты используется функция `MONTHNAME(дата)`, которая возвращает название месяца на английском языке для указанной даты.

`MONTHNAME('2020-04-12')='April'`

Вывести название месяца и количество командировок для каждого месяца. Считаем, что командировка относится к некоторому месяцу, если она началась в этом месяце:
```sql
SELECT MONTHNAME(date_first) AS Месяц, COUNT(*) AS Количество
FROM trip
GROUP BY MONTHNAME(date_first)
/* GROUP BY Месяц */
ORDER BY Количество DESC, Месяц;
```

- Если группировка осуществляется по вычисляемому столбцу (в данном случае «вычисляется» название месяца), то после `GROUP BY`можно указать как вычисляемое выражение, так и имя столбца, заданное с помощью `AS`.
  <font style="color:red">Важно отметить</font>, что последний вариант (указать имя столбца)  нарушает стандарт по порядку выполнения запросов, но иногда может встречаться на реальных платформах.

##### Пример разбора работы HAVING
Вывести фамилию с инициалами и общую сумму суточных, полученных за все командировки для тех сотрудников, которые были в командировках больше чем 3 раза, в отсортированном по убыванию сумм суточных виде:
```sql
SELECT name, SUM((DATEDIFF(date_last, date_first) + 1) * per_diem) AS Сумма  
FROM trip  
GROUP BY name  
HAVING COUNT(*) > 3  
ORDER BY Сумма DESC;
```

> `HAVING` фильтрует группы строк, а не индивидуальные строки.
> В приведенном примере строки группируются по столбцу `name`.
> При этом после группировки, в каждой группе может оказаться по несколько строк. `HAVING` работает со всеми строками, попавшими в группу.
> 
> Как в приведенном примере, условие `HAVING COUNT(*) > 3` проверяет, что в группу попало более 3 записей => сотрудник был в командировках более 3 раз.

### 1.7
#### Использование временного имени таблицы (алиаса)
> Алиас - это псевдоним, который мы присваивали столбцам или таблицам после ключевого слова `AS`

Два способа присваивания псевдонима:
- с использованием ключевого слова `AS`
```sql
FROM fine AS f, traffic_violation AS tv
```
- и без него
```sql
FROM fine f, traffic_violation tv
```

Пример:
```sql
UPDATE fine AS f, traffic_violation tv
SET f.sum_fine = tv.sum_fine
WHERE f.violation = tv.violation AND f.sum_fine IS NULL;
```

#### Группировка данных по нескольким столбцам
> В разделе `GROUP BY` можно указывать несколько столбцов, разделяя их запятыми. Тогда к одной группе будут относиться записи, у которых значения столбцов, входящих в группу, равны.

```sql
SELECT name, number_plate, violation, count(*)
FROM fine
GROUP BY name, number_plate, violation;
```
![[Pasted image 20240515173633.png]]
- Записи таблицы **`fine`** разделяются на группы.
  В каждую группу включаются строки, у которых равны значения в столбцах `name`, `number_plate` и `violation`.

<font style="color:red">ВАЖНО</font>: В разделе `GROUP BY` нужно перечислять все НЕАГРЕГИРОВАННЫЕ столбцы (к которым не применяются групповые функции) из `SELECT`

В таблице `fine` увеличить в два раза сумму неоплаченных штрафов для тех водителей, которые на одной машине нарушили одно и то же правило два и более раз.
```sql
UPDATE fine f,
	   (SELECT name, number_plate, violation
	   FROM fine
	   GROUP BY name, number_plate, violation
	   HAVING COUNT(violation) >= 2) AS query_f
	   /*Тут важно заключать вложенный запрос в скобки ()*/
SET sum_fine = sum_fine * 2
WHERE date_payment IS NULL
	  AND f.name = query_f.name
	  AND f.number_plate = query_f.number_plate
	  AND f.violation = query_f.violation;
```


## Запросы SQL к связанным таблицам
### 2.1 Связи между таблицами
#### One-to-Many
> Связь «**один ко многим**» имеет место, когда одной записи главной таблицы соответствует несколько записей связанной таблицы, а каждой записи связанной таблицы соответствует только одна запись главной таблицы.

Рассмотрим связь one-to-many на примере таблиц `book` и `author` (с условием, что <font style="color:red">у одной книги может быть только один автор</font>):
![[Pasted image 20240704134925.png]]
- таблица `author` называется главной (<font style="color:red">one</font>),
  таблица `book` – связанной или подчиненной (<font style="color:red">many</font> - `FK` всегда находится тут).
- В связанной таблице (`book`), связанный столбец (внешний ключ, `FOREIGN KEY`) должен соответствовать по типу данных ключевому столбцу (`author_id`) главной таблицы (`author`).

#### Many-to-many
> Связь «**многие ко многим**» имеет место когда каждой записи одной таблицы соответствует несколько записей во второй, и наоборот, каждой записи второй таблицы соответствует несколько записей в первой.

Рассмотрим связь many-to-many на примере таблиц `book` и `author` (Один автор может написать несколько книг, а одна книга может быть написана несколькими авторами) :
![[Pasted image 20240704135042.png]]
- для установления связи many-to-many для двух таблиц используется третья, связывающая, таблица, состоящая из двух столбцов (`FK` ссылающиеся на `PK` связываемых таблиц, которые должны совпадать по типу данных).

#### Создание таблицы с внешними ключами (FK)
При создании зависимой таблицы (таблицы, которая содержит `FK`) необходимо учитывать:
- каждый внешний ключ должен иметь такой же тип данных, как связанное поле главной таблицы (`PK`).
- необходимо указать главную для нее таблицу и столбец, по которому осуществляется связь:
```sql
FOREIGN KEY (связанное_поле_зависимой_таблицы)
REFERENCES главная_таблица (связанное_поле_главной_таблицы)
```

<br>
По умолчанию любой столбец, кроме ключевого, может содержать значение `NULL`. При создании таблицы это можно переопределить,  используя  ограничение `NOT NULL` для этого столбца:

```sql
CREATE TABLE таблица(
	столбец_1 INT NOT NULL,
	столбец_2 VARCHAR(10)
	);
```

- для `FK` рекомендуется устанавливать ограничение `NOT NULL` (<font style="color:red">НО все зависит от бизнес логики</font>).

```sql
CREATE TABLE book(
book_id INT PRIMARY KEY AUTO_INCREMENT,
title VARCHAR(50),
author_id INT NOT NULL,
genre_id INT,
price DECIMAL(8, 2),
amount INT,
FOREIGN KEY (author_id) REFERENCES author (author_id),
FOREIGN KEY (genre_id) REFERENCES genre (genre_id)
);
```

#### Действия при удалении записи главной таблицы
> С помощью выражения `ON DELETE` можно установить **действия**, которые выполняются для записей подчиненной таблицы **при удалении связанной строки из главной таблицы**.

При удалении можно установить следующие опции:
- `CASCADE`: автоматически удаляет строки из зависимой таблицы при удалении связанных строк в главной таблице.
- `SET NULL`: при удалении  связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение **`NULL`**. (В этом случае столбец внешнего ключа должен поддерживать установку `NULL`).
- `SET DEFAULT` похоже на `SET NULL` за тем исключением, что значение  внешнего ключа устанавливается не в `NULL,` а в значение по умолчанию для данного столбца.
- `RESTRICT`: отклоняет удаление строк в главной таблице при наличии связанных строк в зависимой таблице.

```sql
CRATE TABLE book(
book_id INT PRIMARY KEY AUTO_INCREMENT,
title VARCHAR(50),
author_id INT NOT NULL,
genre_id INT,
price DECIMAL(8, 2),
amount INT,
FOREIGN KEY (author_id) REFERENCES author (author_id) ON DELETE CASCADE,
FOREIGN KEY (genre_id) REFERENCES genre (genre_id) ON DELETE SET NULL
);
```

### 2.2 Запросы на выборку, соединение таблиц
> Операция соединения `JOIN` предназначена для обеспечения выборки данных из двух таблиц и включения этих данных в один результирующий набор.
> При необходимости соединения не двух, а нескольких таблиц, операция соединения применяется несколько раз (последовательно).

[Видео: коротко и понятно о JOIN](https://www.youtube.com/watch?v=PTAkqURmI0s)

#### Соединение INNER JOIN
> `INNER JOIN` соединяет только строки двух таблиц, для которых условие соединения (после оператора `ON`) истинно.
> Порядок таблиц для оператора неважен, поскольку оператор является симметричным.

![[Pasted image 20240620000435.png | 350]]

```sql
SELECT column_1, column_2
FROM table_1 INNER JOIN table_2 ON условие
```

Результат запроса формируется следующим образом:
- каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы;
- для полученной «соединённой» строки проверяется условие соединения;
- если условие истинно, в таблицу результата добавляется соответствующая «соединённая» строка;

**Example**
> Вывести название, жанр и цену тех книг, количество которых больше 8, в отсортированном по убыванию цены виде.

![[Pasted image 20240620000030.png]]

```sql
SELECT title, name_genre, price
FROM book INNER JOIN genre
	 ON book.genre_id = genre.genre_id
WHERE amount > 8
ORDER BY price DESC;
```

#### Внешнее соединение LEFT и RIGHT OUTER JOIN
> Оператор внешнего соединения `LEFT OUTER JOIN`  (можно использовать `LEFT JOIN`) соединяет две таблицы.
> 
> В результирующую таблицу попадают записи:
> - для которых условие соединения истинно (результат `INNER JOIN`)
> - оставшиеся записи левой таблицы (которая слева от `LEFT JOIN`) .
> 
> Порядок таблиц для оператора важен, поскольку оператор не является симметричным.

Результат запроса формируется так:

1. в результат включается внутреннее соединение (`INNER JOIN`) первой и второй таблицы в соответствии с условием;
2. затем в результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на шаге 1, для таких записей соответствующие поля второй таблицы заполняются значениями `NULL`.

<font style="color:red">ПРИМЕЧАНИЕ</font>: `RINGHT JOIN` работает аналогично, только оставшиеся записи  (для которых условие соединения `false`) добавляются из правой таблицы.

![[Pasted image 20240620173715.png | 600]]

##### Порядок выполнения SQL команд
1. **FROM** (выбор таблицы)
2. **JOIN** (комбинация с подходящими по условию данными из других таблиц)
3. **WHERE** (фильтрация строк)
4. **GROUP BY** (агрегирование данных)
5. **HAVING** (фильтрация агрегированных данных)
6. **SELECT** (возврат результирующего датасета)
7. **ORDER BY** (сортировка)
8. **LIMIT** (ограничение кол-ва вывода строк)

##### Examples
![[Pasted image 20240620000030.png]]

**Example 1**
> Вывести название всех книг каждого автора, если книг некоторых авторов в данный момент нет на складе – вместо названия книги указать `Null`.

```sql
SELECT name_author, title
FROM author LEFT JOIN book
	 ON author.author_id = book.author_id
ORDER BY name_author;
```

**Example 2**
> Вывести все жанры, которые не представлены в книгах на складе
```sql
SELECT name_genre
FROM genre LEFT JOIN book
	 ON genre.genre_id = book.genre_id
WHERE title IS NULL;
```

Порядок выполнения запроса:
1. **FROM**: Определяются таблицы, задействованные в запросе (`genre` и `book`).
2. **JOIN**: объединение двух таблиц на основе условия объединения
   (`ON genre.genre_id = book.genre_id`).
3. **WHERE**: применяется условие фильтрации.
   - хоть мы и выбираем только один столбец `name_genre`, на данном этапе, в объединенной таблице, у нас есть все столбцы двух таблиц.
   - Нам нужно отобрать все жанры, которые **не представлены** в таблице `book`. А это те записи, для которых не выполнится условие объединения. Но т.к. мы используем `LEFT JOIN` (и слева у нас таблица `genre`) эти записи добавятся с заполненными столбцами из таблицы `genre` и со значением **NULL** в столбцах таблицы `book`.
   - Нужные нам значения мы можем отобрать, сравнив любой столбец таблицы `book` c **NULL**.
     <font style="color:red">ПРИМЕЧАНИЕ</font>: Для сравнения с пустым значением используется запись `IS Null` (написать `= Null` нельзя)
4. **SELECT**: выбор столбцов.
   Из всей совокупности столбцов объединенной таблицы оставляем только один столбец `name_genre`.

#### Перекрестное соединения CROSS JOIN
> Оператор перекрёстного соединения, или декартова произведения `CROSS JOIN` соединяет две таблицы.
> Порядок таблиц для оператора неважен, поскольку оператор является симметричным.

```sql
SELECT ...
FROM таблица_1 CROSS JOIN таблица_2
...
```
> В запросе вместо ключевых слов можно поставить запятую между таблицами:

```sql
SELECT ...
FROM таблица_1, таблица_2
...
```

> Результат запроса формируется так:
> Каждая строка одной таблицы соединяется с каждой строкой другой таблицы, формируя  в результате все возможные сочетания строк двух таблиц

**Example 1**
```sql
SELECT name_author, name_genre
FROM author, genre;
```
Каждому автору из таблицы `author` поставит в соответствие все возможные жанры из таблицы `genre`:
![[Pasted image 20240628001802.png | 350]]

**Example 2**
> Необходимо в каждом городе провести выставку книг каждого автора в течение 2020 года. Дату проведения выставки выбрать случайным образом. Создать запрос, который выведет город, автора и дату проведения выставки. Последний столбец назвать **Дата**. Информацию вывести, отсортировав сначала в алфавитном порядке по названиям городов, а потом по убыванию дат проведения выставок.

```sql
SELECT name_city,
	   name_author,
	   DATE_ADD('2020-01-01', interval FLOOR(RAND() * 365) DAY) AS Дата
	   
FROM city CROSS JOIN author
ORDER BY name_city, 3 DESC;
```

##### Функция RAND()
> Генерации случайных чисел в интервале: `0 =< число < 1`.

```sql
FLOOR(RAND() * 365)
```
 Генерация случайного числа от 0 до 364.

##### Функция DATE_ADD()
> Cложения  даты с числом.

`DATE_ADD(дата, INTERVAL число единица_измерения)`
где:
- **единица_измерения** (использовать прописные буквы) – это день (DAY), месяц(MONTH), неделя(WEEK) и пр.,
- **число** – целое число,
- **дата** – значение даты или даты и времени.`

```sql
DATE_ADD('2020-02-02', INTERVAL 45 DAY)  возвращает 18 марта 2020 года DATE_ADD('2020-02-02', INTERVAL 6 MONTH) возвращает 2 августа 2020 года
```

#### Запросы на выборку из нескольких таблиц
> Запрос на выборку может выбирать данные из двух и более таблиц базы данных.
> При этом **таблицы** должны быть **логически связаны** между собой (эта связь не обязательно по FK).
> 
> Для каждой пары таблиц, включаемых в запрос, необходимо указать свой оператор соединения (например `INNER JOIN`).

**Example 1**
> Три таблицы связаны между собой по FK

![[Pasted image 20240628212419.png]]

```sql
SELECT ...
FROM first INNER JOIN third ON first.first_id = third.first_id
		   INNER JOIN second ON third.second_id = second.second_id
...
```

**Example 2**
> Вывести информацию о книгах (жанр, книга, автор), относящихся к жанру, включающему слово «роман» в отсортированном по названиям книг виде.

![[Pasted image 20240628212744.png]]

```sql
SELECT name_genre, title, name_author
FROM genre INNER JOIN book ON genre.genre_id = book.genre_id
		   INNER JOIN author ON book.author_id = author.author_id
WHERE name_genre LIKE '%роман%'
ORDER BY title;
```

#### Запросы для нескольких таблиц с группировкой
> В запросах с групповыми функциями могут использоваться несколько таблиц, между которыми используются различные типы соединений.

**Example 1**
> Вывести количество различных книг каждого автора. Информацию отсортировать в алфавитном порядке по фамилиям авторов.

```sql
SELECT name_author, count(title) AS Количество
FROM author INNER JOIN book on author.author_id = book.author_id
GROUP BY name_author
ORDER BY name_author;
```

- Но при таком типе соединения `INNER JOIN` в результирующую таблицу не попадут авторы, у которых нет книг на складе, но гипотетически могут быть.
  Чтобы выбрать всех авторов, необходимо изменить тип соединения на `LEFT JOIN`.

**Example 2**
> Посчитать количество экземпляров  книг каждого автора из таблицы `author`. 
> Вывести тех авторов,  количество книг которых меньше 10, в отсортированном по возрастанию количества виде.
> Последний столбец назвать `Количество`.

![[Pasted image 20240628222105.png]]

```sql
SELECT name_author, SUM(amount) AS Количество
FROM author LEFT JOIN book ON author.author_id = book.author_id
GROUP BY name_author
HAVING SUM(amount) < 10 OR COUNT(title) = 0
ORDER BY 2;
```

- `OR COUNT(title) = 0` - учитываем, что у автора вообще может не быть книг (то есть `NULL`)

![[Pasted image 20240628222426.png | 300]]

#### Запросы для нескольких таблиц со вложенными запросами
> В запросах, построенных на нескольких таблицах, можно использовать вложенные запросы.
> Вложенный запрос может быть включен:  после ключевого слова `SELECT`,  после `FROM` и в условие отбора после `WHERE (HAVING)`.

##### Examples
###### Example 1
> Вывести авторов, общее количество книг которых на складе максимально.

![[Pasted image 20240629130716.png]]

1. Найдем суммарное количество книг на складе по каждому автору.
```sql
/* Т.к. в таблице book нет имени автора, будем использовать author_id */
SELECT author_id, SUM(amount) AS sum_amount
FROM book
GROUP BY author_id;
```

|author_id|sum_amount|
|-|-|
|1|8|
|2|23|
|3|21|
|4|2|

2. Найдем максимальное кол-во книг из результирующей таблицы предыдущего запроса.
   > Для этого, предыдущему запросу необходимо присвоить имя (например, `query_in`) и использовать его в качестве таблицы-источника после `FROM`

```sql
SELECT MAX(sum_amount) AS max_sum_amount
FROM (SELECT author_id, SUM(amount) AS sum_amount
	  FROM book
	  GROUP BY author_id) query_in;
```

|max_sum_amount|
|-|
|23|

3. Выведем фамилию автора и общее количество книг для него.
```sql
SELECT name_author, SUM(amount) as Количество
FROM author INNER JOIN book on author.author_id = book.author_id
GROUP BY name_author
```
|name_author|Количество|
|-|-|
|Булгаков М.А.|8|
|Достоевский Ф.М.|23|
|Есенин С.А.|21|
|Пастернак Б.Л.|2|

4. Включим запрос с шага 2 в условие отбора запроса с шага 3.
   И получим всех авторов, общее количество книг которых максимально.

```sql
SELECT name_author, SUM(amount) as Количество
FROM author INNER JOIN book on author.author_id = book.author_id
GROUP BY name_author
HAVING SUM(amount) =
		(/* вычисляем максимальное количество книг */
		SELECT MAX(sum_amount) AS max_sum_amount
		FROM
			 (/* считаем количество книг каждого автора */
			 SELECT author_id, SUM(amount) AS sum_amount
			 FROM book
			 GROUP BY author_id) query_in
			 );
```

|name_author|Количество|
|-|-|
|Достоевский Ф.М.|23|

###### Example 2
> Вывести в алфавитном порядке всех авторов, которые пишут только в одном жанре.

![[Pasted image 20240629130716.png]]

1. Найдем `id` всех авторов, которые пишут в одном жанре

```sql
SELECT author.author_id
FROM author INNER JOIN book ON author.author_id = book.author_id
GROUP BY author.author_id
HAVING COUNT(DISTINCT genre_id) = 1;
```

2. Получим имена авторов по найденным `id` из предыдущего запроса

```sql
SELECT DISTINCT name_author
FROM author 
/*
JOIN не обязательный тут, т.к. работаем только со столбцами таблицы author
*/
			INNER JOIN book ON author.author_id = book.author_id
WHERE author.author_id IN(
						SELECT author.author_id
						FROM author INNER JOIN book
									ON author.author_id = book.author_id
						GROUP BY author.author_id
						HAVING COUNT(DISTINCT genre_id) = 1)
```


> Или можно все одним запросом (без вложенных)
```sql
SELECT DISTINCT name_author
FROM author INNER JOIN book ON author.author_id = book.author_id
GROUP BY name_author
HAVING COUNT(DISTINCT genre_id) = 1
order by 1;   
```

##### Выводы
 > После JOIN-а таблиц мы получаем одну таблицу, которая включает **ВСЕ** столбцы как первой, так и второй таблицы.
```sql
SELECT *
FROM author INNER JOIN book ON author.author_id = book.author_id;
```

#### Вложенные запросы в операторах соединения
> Вложенные запросы могут использоваться в операторах соединения `JOIN`. 
> При этом им необходимо присваивать имя, которое записывается сразу после закрывающей скобки вложенного запроса.

```sql
SELECT ...
FROM таблица ... JOIN ( SELECT ... ) имя_вложенного_запроса
				 ON условие ...
```

Вложенный запрос может стоять как справа, так и слева от оператора `JOIN`. Допускается использование двух запросов в операторах соединения.

##### Example
![[Pasted image 20240629130716.png]]

> Вывести информацию о книгах (название книги, фамилию и инициалы автора, название жанра, цену и количество экземпляров книги), написанных в самых популярных жанрах, в отсортированном в алфавитном порядке по названию книг виде.
> Самым популярным считать жанр, общее количество экземпляров книг которого на складе максимально.

1. Вычислим кол-во книг у самого(-ых) популярного(-ых) жара(-ов).
```sql
SELECT genre_id, SUM(amount) AS sum_amount
FROM book
GROUP BY genre_id
ORDER BY sum_amount DESC
LIMIT 1;
```
- Рекомендуется, если запрос будет использоваться в качестве вложенного (особенно в операциях соединения), вычисляемым полям запроса давать собственное имя.

2. На основе предыдущего запроса, найдем `id` самых популярных жанров.
```sql
SELECT q1.genre_id
FROM
	(/* выбираем id жанра и количество произведений, относящихся к нему */
	SELECT genre_id, SUM(amount) AS sum_amount
	FROM book
	GROUP BY genre_id
	) q1
	
	INNER JOIN
	
	(/* выбираем id жанра с максимальным количеством книг */
	SELECT genre_id, SUM(amount) AS sum_amount
	FROM book
	GROUP BY genre_id
	ORDER BY sum_amount DESC
	LIMIT 1
	) q2
	
	ON q1.sum_amount = q2.sum_amount
	
```

3. Получим необходимую нам информацию о книгах
```sql
SELECT title, name_author, name_genre, price, amount
FROM author INNER JOIN book ON author.author_id = book.author_id
			INNER JOIN genre ON book.genre_id = genre.genre_id
GROUP BY title, name_author, name_genre, price, amount, genre.genre_id
HAVING genre.genre_id IN(
	/* выбираем книги с самыми популярными жанрами */
	SELECT q1.genre_id
	FROM
		(/* выбираем id жанра и количество произведений, относящихся к нему */
		SELECT genre_id, SUM(amount) AS sum_amount
		FROM book
		GROUP BY genre_id
		) q1
		
		INNER JOIN
		
		(/* выбираем id жанра с максимальным количеством книг */
		SELECT genre_id, SUM(amount) AS sum_amount
		FROM book
		GROUP BY genre_id
		ORDER BY sum_amount DESC
		LIMIT 1
		) q2
		
		ON q1.sum_amount = q2.sum_amount
)
ORDER BY title;
```

<font style="color:red">ВАЖНО</font>:
1. После `GROUP BY` включен столбец `genre_id`, хотя в `SELECT` его нет.
   - добавление столбца `genre_id`не влияет на группировку, так как между названием жанра(`name_genre`) и его **id** - взаимно-однозначное соответствие.
   - столбец`genre_id` включен в `GROUP BY`, чтобы его можно было использовать в `HAVING`.
   - в `HAVING` можно использовать либо столбцы, перечисленные в `GROUP BY`, либо вычисляемые с помощью групповых функций столбцы.
<br>
2. Название столбца `genre_id` задается с указанием имени таблицы (`genre.genre_id`), так как этот столбец входит в структуру двух таблиц **`book`** и **`genre`**. 
   Для этого запроса можно было бы указать и `book.genre_id`, т.к. они идентичны.
<br>
3. Для вывода inf-ии о цене и кол-ве книг, добавляем столбцы `price` и `amount` в `GROUP BY` и `SELECT`. Эти столбцы напрямую связаны с названием книги `title`. У кажной книги своя цена и кол-во.

#### Операция соединение, использование USING()
> При описании соединения таблиц с помощью `JOIN` в некоторых случаях вместо **`ON`** и следующего за ним условия можно использовать оператор **`USING()`**.
> 
> `USING` позволяет указать столбец, у которого **одинаковое имя** в обеих объединяемых таблицах.
> 
> Для корректной работы столбцы должны не только одинаково называться, но и быть логически связанными (это уже вопрос **корректного составления условия соединения**)
> 
> При этом после **`SELECT`**, при использовании столбцов из `USING()`, необязательно указывать, из какой именно таблицы берется столбец.

- Вариант с **`ON`**:
```sql
SELECT title, name_author, author.author_id /* явно указать таблицу -
																обязательно */
FROM author INNER JOIN book
			ON author.author_id = book.author_id;
```
- Вариант с **`USING`**:
```sql
SELECT title, name_author, author_id /* имя таблицы, из которой берется
										author_id, указывать не обязательно */
FROM author INNER JOIN book USING(author_id);
```

Вариант с **`ON`** является более общим и гибким случаем:
- позволяет задавать соединение не только по одноименным полям;
- позволяет использовать произвольное условие на соединение таблиц, при этом в условие может включаться произвольное выражение, например, можно указать связь двух таблиц по двум и более столбцам.

> По этому использование **`USING`** достаточно ограниченное.


### 2.3 Запросы корректировки, соединение таблиц
#### Запросы на обновление, связанные таблицы
> В запросах на обновление можно использовать связанные таблицы.
> При этом исправлять данные можно во всех используемых в запросе таблицах.

```sql
UPDATE таблица_1 ... JOIN таблица_2 ON выражение ...
SET ...
WHERE ...;
```

##### Examples
> Если таблицы логически связаны по двум и более столбцам (на рисунке связи обозначены линиями), возможно через другие таблицы, условие соединение будет включать связи по нужным столбцам через логический оператор **`AND`**:

![[Pasted image 20240704151939.png]]

###### Example 1
> Для книг, которые уже есть на складе (в таблице **`book`**) по той же цене, что и в поставке (`supply`), увеличить количество на значение, указанное в поставке, а также обнулить количество этих книг в поставке.

```sql
UPDATE author INNER JOIN book ON author.author_id = book.author_id
			  INNER JOIN supply ON book.title = supply.title
								   AND author.name_author = supply.author
SET book.amount = book.amount + supply.amount,
	supply.amount = 0
WHERE book.price = supply.price;
```


#### Запросы на добавление, связанные таблицы
> Запросом на добавление можно добавить записи, отобранные с помощью запроса на выборку, который включает несколько таблиц.

```sql
INSERT INTO таблица (список_полей)
SELECT список_полей_из_других_таблиц
FROM таблица_1 ... JOIN таблица_2 ON ...
...
```

##### Examples
![[Pasted image 20240704151939.png]]
###### Example 1
> Включить новых авторов в таблицу `author` с помощью запроса на добавление.
> Новыми считаются авторы, которые есть в таблице `supply`, но нет в таблице `author`.

```sql
INSERT INTO author(name_author)
SELECT supply.author
FROM author RIGHT JOIN supply ON author.name_author = supply.author
WHERE name_author IS NULL;
```

###### Example 2
> Добавить новые записи о книгах, которые есть в таблице `supply` и нет в таблице **`book`**.
> Новыми книгами считать те, у которых `supply.amount <> 0`

- Поскольку в таблице `supply` не указан жанр книги, оставить его пока пустым (занести значение `Null`).
> Если нужно оставить какое-то поле пустым - его просто не указывают в списке полей таблицы, в которую добавляются записи.
- Прежде всего необходимо сформировать запрос с полями, которые соответствуют полям таблицы `book`, так как использовать только таблицу `supply` нельзя - в ней вместо кода автора стоит его фамилия.

```sql
INSERT INTO book(title, author_id, price, amount)
SELECT title, author_id, price, amount
FROM author INNER JOIN supply ON author.name_author = supply.author
WHERE supply.amount <> 0;
```

#### Удаление записей, использование связанных таблиц
> При удалении записей из таблицы можно использовать информацию из других связанных с ней таблиц.

Синтаксис:
```sql
DELETE FROM таблица_1
USING таблица_1 INNER JOIN таблица_2 ON ...
WHERE ...
```

<font style="color:red">ВАЖНО</font>: После **USING** используется оператор соединения `JOIN`, в котором должна фигурировать **таблица, из которой удаляются записи** (`таблица_1`) (не обязательно первой).

##### Example
> Удалить всех авторов, которые пишут в жанре `Поэзия`.
> Из таблицы `book` удалить все книги этих авторов.
> В запросе для отбора авторов использовать полное название жанра, а не его `id`.

```sql
DELETE FROM author
USING author INNER JOIN book USING(author_id)
			 INNER JOIN genre ON book.genre_id = genre.genre_id
WHERE genre.name_genre = 'Поэзия';
```

- Книги из таблицы `book` будут удалены автоматически, так как для столбца `author_id` из таблицы `book` установлено `ON DELETE CASCADE`.

### 2.4
#### Оператор UNION
> Оператор `UNION` используется для объединения двух и более SQL запросов, его синтаксис:

```sql
SELECT столбец_1_1, столбец_1_2, ...
FROM
...
UNION
SELECT столбец_2_1, столбец_2_2, ...
FROM
...
```
или
```sql
SELECT столбец_1_1, столбец_1_2, ...
FROM
...
UNION ALL
SELECT столбец_2_1, столбец_2_2, ...
FROM
...
```

Каждый из запросов (`SELECT`) должен иметь:
-  одинаковое количество столбцов
- совместимые типы возвращаемых данных

В результате выполнения этой конструкции будет выведена таблица:
- имена столбцов которой соответствуют именам столбцов в первом запросе;
- сначала отображаются записи-результаты первого запроса, а затем второго;

> Если указано ключевое слово `ALL`, то в результат включаются все записи запросов, в противном случае - различные (как `DISTINCT`).

##### Examples
> Вывести всех клиентов, которые делали заказы или в этом, или в предыдущем году.

На этом примере рассмотрим разницу между `UNION` и `UNION ALL`.

1. С `UNION` клиенты будут выведены без повторений
```sql
SELECT name_client
FROM buy_archive INNER JOIN client USING(client_id)

UNION

SELECT name_client
FROM buy INNER JOIN client USING(client_id)
```

|name_client|
|-|
|Баранов Павел|
|Абрамова Катя|
|Яковлева Галина|
|Семенонов Иван|

2. C `UNION ALL` будут выведены клиенты с повторением
```sql
SELECT name_client
FROM buy_archive INNER JOIN client USING(client_id)

UNION ALL

SELECT name_client FROM buy INNER JOIN client USING(client_id)
```

|name_client|
|-|
|Баранов Павел|
|Баранов Павел|
|Абрамова Катя|
|Абрамова Катя|
|Абрамова Катя|
|Яковлева Галина|
|Яковлева Галина|
|Баранов Павел|
|Абрамова Катя|
|Абрамова Катя|
|Баранов Павел|
|Баранов Павел|
|Абрамова Катя|
|Семенонов Иван|

> Можно сделать **сортировку** по всем объединенным записям.
> Для этого `ORDER BY` указываются после последнего запроса:

```sql
SELECT name_client
FROM buy_archive INNER JOIN client USING(client_id)

UNION

SELECT name_client
FROM buy INNER JOIN client USING(client_id)

ORDER BY name_client
```